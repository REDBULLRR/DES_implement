#include<bitset>    // bits operation and memory saving
#include<iostream>  // std::cout
#include<fstream>   // file I/O
#include<string>    // std::string
#include<iomanip>   // std::hex
#include<algorithm> // std::reverse
using namespace std;

const int N_TEST = 5;       // 測資數
const int BYTE_SIZE = 8;    // 單個 byte 擁有的 bit 數
const int MAX_STR_SIZE = 8; // str_to_binary(string) 一次能轉換的最大 string 長度

string DES(string plaintext, string key);
// Return the cipher text generated by encrypting a given plaintext (8-characters) with a given key (8-characters) using DES

bitset<56> applying_PC_1(bitset<64> originKey);
// Apply PC-1 to the origin key (64-bits)

bitset<64> str_to_binary(string aStr);
// Transform a chracter string to binary bits according to ASCIIS
// aStr: maximum to 8 characters (expect exactly 8 charcters)
// Every character will be converted to bitset<8> type.
// Ex: "A" -(ASCII)-> "41"(Hex) --> "0010 1001"(binary); 
// Ex: "0" -(ASCII)-> "30"(Hex) --> "0001 1110"(binary).

// =========== Main Function ============
int main()
{
  // purpose
  cout <<"This program performs DES encryption."<<endl;
  
  // 從 DES-Key-Plaintext.txt 讀入測資
  ifstream inFile;
  ofstream outFile;
  
  inFile.open("DES-Key-Plaintext.txt"); // 開檔
  outFile.open("out.txt");
  
  // Loop though pairs of (key, plaintext)
  for(int i=0; i<N_TEST; i++)
  {
    // 從 DES-Key-Plaintext.txt 依序得到 key 和 plaintext
    string plaintext, key;
    inFile>>key>>plaintext;
    
    // Get the cipher text
    cout <<DES(plaintext, key)<<endl; 
  }
  
  return 0;
}

// =========== Sub Function ============
string DES(string plaintext, string key)
{
  bitset<64> plaintext_2, key_2; // plaintext and key in binary
  
  // Step1: 將 plaintext 和 key 轉換為 64-bits binary form
  plaintext_2 = str_to_binary(plaintext);
  key_2 = str_to_binary(key);
  
  // Step2: 產生 Sub keys
  
  // Step3: 
  
  // Step4:
  
  // Step5:
  
  return cipherText;
}
  
// newKey assign 出了問題，未解決
bitset<56> applying_PC_1(bitset<64> originKey)
{
  int PC_1[]={57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4};

  bitset<56> newKey;

  // 由 originKey 的最右為 1st ，最左為 64th 來對應：不太對
  /*
  for(int i=0; i<64; i++)
    newKey[i] = originKey[PC_1[i]];
  */
  
  // 由 originKey 最左端為 1st，最右端為 64th 來對應
  // i=63 是第一個（最左邊的） bit，i=0 是第 64 個（最右邊的） bit
  for(int i=63; i>=0; i--)
  {
    int newIdx=64-PC_1[63-i];
    newKey[i] = originKey[newIdx];

    //test
    cout <<"newLdx="<<newIdx<<", originKey[newIdx]="<<originKey[newIdx]<<endl<<newKey<<endl;
    
    //cout <<"For i="<<i<<", \nnewKey="<<newKey<<", \nPC_1[63-i]="<<PC_1[63-i]<<", \noriginKey["<<64-PC_1[63-i]<<"]="<<originKey[64-PC_1[63-i]]<<endl<< endl;

    if (i==50) break;
  }
  
  //test
  cout <<"newKey="<<newKey<<endl;
  return newKey;
}


bitset<64> str_to_binary(string aStr)
{
  // 檢查 aStr 大小，超過 MAX_STR_SIZE 為非法，回傳 bitset=0 
  if (aStr.size() > MAX_STR_SIZE)  
  {
    cout <<"Size Error: aStr size too big:"<<aStr.size()<<endl;
    return bitset<64>(string("0")); // 不確定能否這樣寫
  }
  
  string eightBytes="";
  
  for(int i=0; i<BYTE_SIZE; i++)
  {
    int ascii = aStr[i];
    
    //test
    //cout <<"For aStr[i]="<<aStr[i]<<", ascii="<<ascii<<endl;

    string aByte="";
    
    // 將單一字元轉換為其 ASCII 的二進位表示法
    for(int j=0; j<8; j++)
    {
      // 除以二的餘數是 1 ，則二進位下第 j+1 位數是 1
      if (ascii%2==1)
        aByte += "1";
      
      // 除以二的餘數是 0 ，則二進位下第 j+1 位數是 1
      else
        aByte += "0";
      
      //test
      //cout <<"For j="<<j<<", ascii="<< ascii <<", aByte="<<aByte<<endl;
      
      ascii /=2;
    
    }
    
    // append the 8-bit string of the character aStr[i] to string eightBytes (who is empty in default)
    for(int j=7; j>=0; j--)
      eightBytes+=aByte[j];
    
    //test
    //cout <<"char:"<<aStr[i]<<", eightBytes="<<eightBytes<<endl << endl;
  }
  
  //test
  //cout <<"eightBytes="<<eightBytes<<endl;

  return  bitset<64>(eightBytes);
}
